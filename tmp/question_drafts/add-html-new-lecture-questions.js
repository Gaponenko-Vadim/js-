
const path = require('path');
const dotenv = require('dotenv');
const { PrismaClient } = require('@prisma/client');
const { PrismaPg } = require('@prisma/adapter-pg');
const { Pool } = require('pg');

dotenv.config({ path: path.resolve(__dirname, '..', '..', '.env') });

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

const accessibilityQuestions = [
  {
    question: 'Что означает доступность (accessibility) в контексте веб‑страницы?',
    options: [
      'Страница понятна и управляется всеми пользователями, включая людей с особенностями',
      'Страница загружается быстрее благодаря оптимизации ресурсов',
      'Страница содержит больше ключевых слов для поисковой выдачи',
      'Страница использует только самые новые теги HTML'
    ],
    correctAnswer: 0,
    explanation: 'Доступность — это возможность пользоваться сайтом всем людям, включая тех, кто использует скринридер или клавиатуру. Это про понимание и управление, а не про скорость или «модные» теги.'
  },
  {
    question: 'Когда стоит использовать ARIA‑атрибуты?',
    options: [
      'Когда семантики и видимого текста недостаточно для понимания элемента',
      'Чтобы заменить все семантические теги на универсальные div',
      'Чтобы ускорить загрузку страницы в поиске',
      'Чтобы автоматически добавить стили для компонентов'
    ],
    correctAnswer: 0,
    explanation: 'ARIA — это «подпорка» для доступности, когда семантики не хватает. Она не заменяет теги и не влияет на скорость или стили.'
  },
  {
    question: 'Что такое landmark в HTML‑доступности?',
    options: [
      'Смысловая зона страницы (например, header, nav, main, footer)',
      'Любой блок с классом container',
      'Служебный комментарий в коде',
      'CSS‑правило, которое задаёт сетку'
    ],
    correctAnswer: 0,
    explanation: 'Landmark — это ориентир, по которому скринридер и пользователи могут быстро перемещаться. Класс container или CSS‑сетка не создают таких ориентиров.'
  },
  {
    question: 'Почему важна иерархия заголовков h1 → h2 → h3?',
    options: [
      'Она создаёт понятную структуру чтения для пользователя и скринридера',
      'Она делает заголовки автоматически крупнее и жирнее',
      'Она нужна только для корректной работы CSS‑анимаций',
      'Она обязательна только в таблицах и списках'
    ],
    correctAnswer: 0,
    explanation: 'Заголовки формируют структуру документа, по которой удобно ориентироваться. Визуальные стили можно менять отдельно, а таблицы и списки не требуют иерархии заголовков.'
  },
  {
    question: 'Почему текст ссылки «Кликни тут» считается плохой практикой?',
    options: [
      'Он не объясняет, куда ведёт ссылка без дополнительного контекста',
      'Он слишком длинный и перегружает страницу',
      'Он запрещён стандартом HTML',
      'Он работает только в некоторых браузерах'
    ],
    correctAnswer: 0,
    explanation: 'Текст ссылки должен быть самодостаточным и понятным. «Кликни тут» ничего не говорит о цели перехода и плохо читается в списке ссылок скринридера.'
  },
  {
    question: 'Что лучше использовать для действия «Открыть фильтры» на текущей странице?',
    options: ['<button>', '<a>', '<span>', '<div>'],
    correctAnswer: 0,
    explanation: 'Кнопка предназначена для действий на текущей странице, поэтому она подходит лучше всего. Ссылка должна вести на другой URL, а span и div не являются интерактивными по умолчанию.'
  },
  {
    question: 'Почему label важен для поля формы?',
    options: [
      'Он связывает поле с подписью и делает ввод понятным',
      'Он заменяет атрибут name при отправке формы',
      'Он автоматически проверяет корректность введённых данных',
      'Он делает поле невидимым для скринридеров'
    ],
    correctAnswer: 0,
    explanation: 'Label связывает смысл и поле, поэтому пользователю понятно, что вводить. Он не заменяет name и не выполняет валидацию.'
  },
  {
    question: 'Почему placeholder не может заменить label?',
    options: [
      'Подсказка исчезает при вводе, и подпись теряется',
      'Placeholder запрещён стандартом HTML',
      'Placeholder всегда отправляется на сервер',
      'Placeholder автоматически делает поле обязательным'
    ],
    correctAnswer: 0,
    explanation: 'Placeholder исчезает, как только пользователь начинает вводить. Подпись label остаётся видимой и доступной всегда.'
  },
  {
    question: 'Какое назначение атрибута alt у контентного изображения?',
    options: [
      'Он описывает смысл изображения для тех, кто его не видит',
      'Он задаёт резервный размер картинки',
      'Он включает ленивую загрузку изображения',
      'Он запрещает скачивание картинки'
    ],
    correctAnswer: 0,
    explanation: 'Alt — текстовая альтернатива изображению, которая читается скринридером и показывается при ошибке загрузки. Он не управляет размером, загрузкой или правами.'
  },
  {
    question: 'Как правильно подписать кнопку‑иконку без видимого текста?',
    options: [
      'Добавить aria-label с понятным действием',
      'Добавить title и убрать кнопку из фокуса',
      'Оборачивать кнопку в div с классом icon',
      'Добавить placeholder к кнопке'
    ],
    correctAnswer: 0,
    explanation: 'Для кнопки‑иконки нужен aria-label, чтобы скринридер произнёс смысл действия. Title не заменяет полноценную подпись, а placeholder к кнопкам не относится.'
  },
  {
    question: 'В каком случае лучше использовать aria-labelledby?',
    options: [
      'Когда есть видимый заголовок и нужно сослаться на него',
      'Когда текст на странице отсутствует и нужен короткий ярлык',
      'Когда нужно скрыть элемент от скринридера',
      'Когда требуется изменить порядок фокуса'
    ],
    correctAnswer: 0,
    explanation: 'aria-labelledby связывает элемент с уже существующим текстом на странице. Для короткой подписи без текста используют aria-label, а не aria-labelledby.'
  },
  {
    question: 'Для чего используется aria-describedby?',
    options: [
      'Чтобы связать элемент с подсказкой или текстом ошибки',
      'Чтобы изменить цвет элемента при фокусе',
      'Чтобы скрыть элемент от скринридера',
      'Чтобы указать URL для перехода'
    ],
    correctAnswer: 0,
    explanation: 'aria-describedby добавляет дополнительное описание, например подсказку или ошибку, и делает его доступным. Он не влияет на стили или навигацию.'
  },
  {
    question: 'Что делает aria-live?',
    options: [
      'Озвучивает динамические изменения, например ошибки формы',
      'Автоматически исправляет текстовые ошибки',
      'Перемещает фокус на первый элемент формы',
      'Скрывает блок от скринридеров'
    ],
    correctAnswer: 0,
    explanation: 'aria-live сообщает скринридеру, что изменения должны быть озвучены. Он не исправляет ошибки и не управляет фокусом.'
  },
  {
    question: 'Какую роль выполняет aria-hidden?',
    options: [
      'Скрывает декоративные элементы от скринридеров',
      'Делает элемент невидимым для всех пользователей',
      'Блокирует таб‑навигацию по странице',
      'Добавляет элементу скрытый заголовок'
    ],
    correctAnswer: 0,
    explanation: 'aria-hidden скрывает элемент только от ассистивных технологий и обычно применяется к декоративным элементам. Он не выключает визуальное отображение и не управляет фокусом.'
  },
  {
    question: 'Что означает tabindex="0"?',
    options: [
      'Элемент включён в естественный порядок табуляции',
      'Элемент полностью исключён из навигации',
      'Элемент всегда получает фокус первым',
      'Элемент становится недоступным для скринридера'
    ],
    correctAnswer: 0,
    explanation: 'tabindex="0" делает элемент доступным в обычном порядке табов. Он не исключает элемент и не даёт ему приоритет перед другими.'
  },
  {
    question: 'Что означает tabindex="-1"?',
    options: [
      'Элемент не попадает в таб‑навигацию, но может получать фокус программно',
      'Элемент всегда первый в порядке табуляции',
      'Элемент недоступен для скринридера',
      'Элемент становится скрытым на странице'
    ],
    correctAnswer: 0,
    explanation: 'tabindex="-1" исключает элемент из таб‑навигации, но он остаётся фокусируемым через скрипт. Это не делает его скрытым или недоступным для чтения.'
  },
  {
    question: 'Почему tabindex="1" и выше считается плохой практикой?',
    options: [
      'Он ломает естественный порядок фокуса и делает навигацию непредсказуемой',
      'Он отключает поддержку клавиатуры в браузере',
      'Он автоматически скрывает элемент',
      'Он запрещён стандартом HTML'
    ],
    correctAnswer: 0,
    explanation: 'Положительный tabindex переопределяет естественный порядок, из‑за чего фокус начинает перескакивать. Это ухудшает доступность и делает страницу неудобной.'
  },
  {
    question: 'Зачем нужна ссылка skip‑link («Перейти к контенту»)?',
    options: [
      'Она позволяет быстро перейти к основному контенту, минуя длинное меню',
      'Она автоматически заполняет формы на странице',
      'Она делает страницу быстрее в поисковой выдаче',
      'Она скрывает навигацию от скринридеров'
    ],
    correctAnswer: 0,
    explanation: 'Skip‑link экономит время пользователям клавиатуры и скринридеров. Она не ускоряет поисковую выдачу и не скрывает меню.'
  },
  {
    question: 'Где логично размещать skip‑link?',
    options: [
      'В начале body перед шапкой и навигацией',
      'Только в конце страницы после footer',
      'Внутри тега head',
      'Внутри каждой карточки курса'
    ],
    correctAnswer: 0,
    explanation: 'Skip‑link должна быть доступна сразу при таб‑навигации, поэтому её размещают в начале body. В head или в конце страницы она не решит задачу.'
  },
  {
    question: 'Что такое screen reader (скринридер)?',
    options: [
      'Программа, которая читает содержимое страницы вслух',
      'Инструмент для проверки HTML‑валидации',
      'Браузерный режим для мобильной вёрстки',
      'Библиотека для оптимизации изображений'
    ],
    correctAnswer: 0,
    explanation: 'Скринридер озвучивает содержимое страницы и помогает людям с нарушением зрения. Он не проверяет валидацию и не связан с оптимизацией.'
  },
  {
    question: 'Как правильно дать имя секции, если заголовок находится внутри неё?',
    options: [
      'Использовать aria-labelledby и сослаться на id заголовка',
      'Добавить aria-label прямо на заголовок',
      'Поставить aria-hidden на секцию',
      'Добавить tabindex="1" к секции'
    ],
    correctAnswer: 0,
    explanation: 'aria-labelledby связывает секцию с существующим заголовком и делает структуру понятной. aria-hidden и tabindex не решают задачу именования.'
  },
  {
    question: 'Нужен ли aria-label для кнопки с видимым текстом «Отправить»?',
    options: [
      'Нет, текст уже является доступным именем кнопки',
      'Да, без aria-label кнопки не читаются',
      'Да, иначе кнопка не отправит форму',
      'Нет, но нужно добавить aria-hidden'
    ],
    correctAnswer: 0,
    explanation: 'Если у кнопки есть видимый текст, он уже служит доступным именем. aria-label нужен, когда текста нет или он непонятен.'
  },
  {
    question: 'Что означает термин focus (фокус) в доступности?',
    options: [
      'Элемент, с которым в данный момент работает клавиатура',
      'Элемент, который отображается самым большим шрифтом',
      'Элемент, который находится в конце страницы',
      'Элемент, скрытый от скринридера'
    ],
    correctAnswer: 0,
    explanation: 'Фокус — это текущий активный элемент для клавиатурной навигации. Он не связан с размером шрифта или положением на странице.'
  },
  {
    question: 'Какая практика соответствует рекомендациям по доступности?',
    options: [
      'Использовать семантические теги и добавлять ARIA только при необходимости',
      'Везде заменять теги на div и добавлять aria-label',
      'Скрывать все иконки и кнопки через aria-hidden',
      'Использовать tabindex="1" для важнейших элементов'
    ],
    correctAnswer: 0,
    explanation: 'Семантика — основа доступности, а ARIA применяется точечно, когда смысла не хватает. Остальные варианты противоречат логике доступного HTML.'
  },
  {
    question: 'Что позволяет пользователю быстрее ориентироваться на странице с помощью скринридера?',
    options: [
      'Семантические ориентиры и правильные заголовки',
      'Большие отступы и яркие цвета',
      'Скрытые дивы с подсказками',
      'Скрипты, которые отключают таб‑навигацию'
    ],
    correctAnswer: 0,
    explanation: 'Скринридеры ориентируются по заголовкам и landmarks, поэтому структура критична. Цвета и отступы не помогают ассистивным технологиям.'
  }
];

const metadataQuestions = [
  {
    question: 'Где размещаются метаданные страницы?',
    options: ['Внутри тега <head>', 'Внутри тега <body>', 'Внутри <main>', 'Внутри <footer>'],
    correctAnswer: 0,
    explanation: 'Метаданные находятся в <head> и не отображаются на странице. В body размещается видимый контент.'
  },
  {
    question: 'Какую роль выполняет тег <title>?',
    options: [
      'Задаёт название вкладки и заголовок в поисковой выдаче',
      'Является главным заголовком страницы для пользователя',
      'Заменяет meta description в поиске',
      'Отвечает за подключение стилей'
    ],
    correctAnswer: 0,
    explanation: '<title> — это имя страницы для вкладки и поисковой выдачи. Главный заголовок на странице задаёт <h1>, а стили подключаются через <link>.'
  },
  {
    question: 'Почему title должен быть уникальным для каждой страницы?',
    options: [
      'Чтобы поисковик отличал страницы и правильно их ранжировал',
      'Чтобы браузер показывал разный шрифт на каждой вкладке',
      'Чтобы можно было обойти ограничения на длину URL',
      'Чтобы автоматически создать оглавление страницы'
    ],
    correctAnswer: 0,
    explanation: 'Уникальный title помогает поисковику понять, чем страницы отличаются. Он не влияет на шрифты и не связан с URL или оглавлением.'
  },
  {
    question: 'Зачем нужен meta description?',
    options: [
      'Он описывает страницу в выдаче и повышает кликабельность',
      'Он заменяет текст на странице',
      'Он гарантирует первое место в поиске',
      'Он скрывает страницу от индексации'
    ],
    correctAnswer: 0,
    explanation: 'Description даёт короткое описание, которое видно в сниппете, и влияет на CTR. Он не заменяет контент и не гарантирует рейтинг.'
  },
  {
    question: 'Что делает meta charset?',
    options: [
      'Задаёт кодировку, чтобы текст отображался корректно',
      'Управляет масштабом страницы на мобильных',
      'Определяет набор ключевых слов для поиска',
      'Блокирует индексацию страницы'
    ],
    correctAnswer: 0,
    explanation: 'charset определяет кодировку, чтобы символы читались правильно. Он не отвечает за масштаб, ключевые слова или индексацию.'
  },
  {
    question: 'Где лучше размещать meta charset?',
    options: [
      'В самом начале <head>',
      'В конце <body>',
      'После всех скриптов',
      'Только на страницах с формами'
    ],
    correctAnswer: 0,
    explanation: 'charset должен быть одним из первых в <head>, чтобы браузер сразу понял кодировку. В body или после скриптов будет поздно.'
  },
  {
    question: 'Для чего нужен meta viewport?',
    options: [
      'Чтобы страница корректно масштабировалась на мобильных',
      'Чтобы задать заголовок в поиске',
      'Чтобы скрыть страницу от роботов',
      'Чтобы автоматически добавить Open Graph'
    ],
    correctAnswer: 0,
    explanation: 'viewport управляет масштабом и шириной на мобильных устройствах. Он не связан с поисковым заголовком и OG‑тегами.'
  },
  {
    question: 'Что произойдёт без meta viewport на телефоне?',
    options: [
      'Страница будет выглядеть уменьшенной и плохо читаемой',
      'Страница перестанет индексироваться',
      'Браузер не покажет title',
      'Скрипты перестанут работать'
    ],
    correctAnswer: 0,
    explanation: 'Без viewport браузер пытается уместить страницу в широкий экран, поэтому всё становится мелким. Индексация и скрипты от этого не зависят.'
  },
  {
    question: 'Когда используют canonical?',
    options: [
      'Когда у страницы есть дубли из‑за параметров или фильтров',
      'Когда нужно скрыть страницу от индексации',
      'Когда хочется заменить title',
      'Когда подключают фавикон'
    ],
    correctAnswer: 0,
    explanation: 'Canonical нужен, чтобы указать основной URL среди дублей. Он не скрывает страницы и не заменяет другие метаданные.'
  },
  {
    question: 'Куда должен указывать canonical для страницы каталога?',
    options: [
      'На текущий основной URL каталога',
      'Всегда на главную страницу сайта',
      'На страницу с контактами',
      'На первый URL, который был создан в проекте'
    ],
    correctAnswer: 0,
    explanation: 'Canonical должен указывать на главную версию именно этой страницы. Если вести всё на главную, поисковик будет путаться.'
  },
  {
    question: 'Что означает директива noindex в meta robots?',
    options: [
      'Запрещает индексировать страницу',
      'Запрещает загружать изображения',
      'Отключает описание в выдаче',
      'Запрещает выполнять скрипты'
    ],
    correctAnswer: 0,
    explanation: 'noindex говорит поисковику не добавлять страницу в выдачу. Он не влияет на изображения или скрипты.'
  },
  {
    question: 'Что означает директива nofollow?',
    options: [
      'Запрещает роботу переходить по ссылкам на странице',
      'Запрещает индексировать саму страницу',
      'Скрывает страницу в соцсетях',
      'Выключает meta description'
    ],
    correctAnswer: 0,
    explanation: 'nofollow относится к ссылкам: робот не должен по ним переходить. Он не скрывает страницу целиком и не влияет на описание.'
  },
  {
    question: 'Для чего нужны Open Graph теги?',
    options: [
      'Для красивой карточки при шаринге в соцсетях',
      'Для расчёта шрифта на странице',
      'Для валидации HTML‑разметки',
      'Для подключения фавикона'
    ],
    correctAnswer: 0,
    explanation: 'Open Graph управляет тем, как страница выглядит при шаринге. Он не влияет на шрифты или валидацию HTML.'
  },
  {
    question: 'Какой OG‑тег задаёт изображение карточки?',
    options: ['og:image', 'og:title', 'og:type', 'og:url'],
    correctAnswer: 0,
    explanation: 'og:image отвечает за картинку превью. Остальные теги задают название, тип и URL.'
  },
  {
    question: 'Зачем нужны Twitter Card теги?',
    options: [
      'Twitter использует собственные метаданные для превью',
      'Они заменяют meta description в поиске',
      'Они делают страницу быстрее',
      'Они скрывают карточку от индексации'
    ],
    correctAnswer: 0,
    explanation: 'Twitter читает свои теги и может не использовать OG. Это отдельный набор метаданных для карточки.'
  },
  {
    question: 'Для чего нужен favicon?',
    options: [
      'Чтобы вкладка и закладка имели узнаваемую иконку',
      'Чтобы автоматически генерировать description',
      'Чтобы скрывать страницу от роботов',
      'Чтобы менять размер шрифта в браузере'
    ],
    correctAnswer: 0,
    explanation: 'Favicon — маленькая иконка для вкладки и закладок, она улучшает узнаваемость. Он не влияет на индексацию и шрифты.'
  },
  {
    question: 'Чем <title> отличается от <h1>?',
    options: [
      '<title> виден в вкладке и выдаче, а <h1> — на странице',
      '<title> — это текст в теле страницы, а <h1> — в head',
      '<title> работает только для соцсетей, а <h1> — для поиска',
      'Разницы нет, можно использовать любой из них'
    ],
    correctAnswer: 0,
    explanation: '<title> находится в head и показывается во вкладке и поиске. <h1> виден пользователю на странице и не заменяет title.'
  },
  {
    question: 'Чем meta description отличается от <h1>?',
    options: [
      'Description используется в выдаче, а <h1> — на самой странице',
      'Description отображается в меню сайта, а <h1> — в футере',
      'Description заменяет title, а <h1> заменяет canonical',
      'Они нужны только для валидаторов HTML'
    ],
    correctAnswer: 0,
    explanation: 'Description — это короткий текст для сниппета, он не виден как часть страницы. <h1> — главный заголовок контента.'
  },
  {
    question: 'Что означает SEO (Search Engine Optimization)?',
    options: [
      'Оптимизация сайта для лучшей видимости в поиске',
      'Система автоматической генерации HTML',
      'Способ ускорить работу браузера',
      'Шифрование пользовательских данных'
    ],
    correctAnswer: 0,
    explanation: 'SEO — это улучшение видимости и качества представления сайта в поиске. Оно не связано с генерацией HTML или шифрованием.'
  },
  {
    question: 'Что из перечисленного обычно находится в <head>?',
    options: [
      'meta description и canonical',
      'основной текст статьи',
      'галерея изображений',
      'форма обратной связи'
    ],
    correctAnswer: 0,
    explanation: 'В head размещают метаданные: description, canonical, og‑теги и т.д. Текст статьи и формы находятся в body.'
  },
  {
    question: 'Нужно ли задавать meta description для каждой публичной страницы?',
    options: [
      'Да, чтобы поисковая выдача была понятной и кликабельной',
      'Нет, description нужен только для главной',
      'Нет, description всегда генерируется браузером',
      'Да, но только для страниц без изображений'
    ],
    correctAnswer: 0,
    explanation: 'Description полезен для каждой важной страницы, потому что влияет на сниппет. Браузер его не генерирует автоматически.'
  },
  {
    question: 'Когда стоит использовать noindex?',
    options: [
      'Для служебных и технических страниц, которые не должны быть в выдаче',
      'Для всех страниц каталога, чтобы скрыть конкурентов',
      'Для любой страницы с формой',
      'Для страниц, где есть Open Graph'
    ],
    correctAnswer: 0,
    explanation: 'noindex применяют к служебным страницам (например, админка, черновики). Каталог и публичные страницы обычно должны индексироваться.'
  },
  {
    question: 'Какой вариант корректен для meta viewport?',
    options: [
      'width=device-width, initial-scale=1',
      'height=device-height, maximum-size=2',
      'device=mobile, scale=100%',
      'screen-size=auto, zoom=off'
    ],
    correctAnswer: 0,
    explanation: 'Стандартная и рекомендованная настройка — width=device-width, initial-scale=1. Остальные варианты не являются корректными.'
  },
  {
    question: 'Что произойдёт без настроенных Open Graph тегов при шаринге?',
    options: [
      'Карточка может выглядеть пустой или случайной',
      'Страница автоматически попадёт в топ поиска',
      'Вкладка браузера изменит иконку',
      'HTML перестанет проходить валидацию'
    ],
    correctAnswer: 0,
    explanation: 'Без OG‑тегов соцсети выбирают случайный текст и изображение или не показывают карточку. На поиск и валидацию это напрямую не влияет.'
  },
  {
    question: 'Какой элемент отвечает за название страницы в поисковой выдаче?',
    options: ['<title>', '<h1>', '<meta name="description">', '<link rel="canonical">'],
    correctAnswer: 0,
    explanation: '<title> — это заголовок, который поисковики показывают в выдаче. <h1> виден на странице, description — это текст сниппета, canonical — URL.'
  }
];

const bestPracticesQuestions = [
  {
    question: 'Зачем использовать семантические теги вместо «голых» div?',
    options: [
      'Они дают структуру и смысл для доступности и SEO',
      'Они автоматически добавляют стили и анимации',
      'Они уменьшают размер изображений',
      'Они делают страницу доступной без текста'
    ],
    correctAnswer: 0,
    explanation: 'Семантические теги передают смысл блоков и помогают ассистивным технологиям. Они не добавляют стили и не влияют на изображения напрямую.'
  },
  {
    question: 'Какой принцип верен для заголовков?',
    options: [
      'Один h1 на страницу и последовательная иерархия уровней',
      'Сколько угодно h1, главное — чтобы был красивый размер',
      'Можно начинать с h3, если так удобнее в дизайне',
      'Заголовки можно заменять div с жирным текстом'
    ],
    correctAnswer: 0,
    explanation: 'Иерархия заголовков отражает структуру документа и помогает навигации. Пропуски уровней и замена div ухудшают семантику.'
  },
  {
    question: 'Почему нельзя пропускать уровень заголовка (h1 → h3)?',
    options: [
      'Это ломает логическую структуру для пользователей и скринридеров',
      'Это запрещено браузерами и ломает CSS',
      'Это делает страницу медленнее',
      'Это автоматически выключает скрипты'
    ],
    correctAnswer: 0,
    explanation: 'Пропуск уровней разрушает структуру документа, по которой ориентируются пользователи и поисковики. Это не связано со скоростью или скриптами.'
  },
  {
    question: 'Чем отличается ссылка от кнопки?',
    options: [
      'Ссылка ведёт на другой URL, кнопка выполняет действие на странице',
      'Ссылка используется только в футере, кнопка — только в шапке',
      'Кнопка всегда должна иметь href',
      'Ссылка не может иметь текста'
    ],
    correctAnswer: 0,
    explanation: 'Ссылка предназначена для навигации, а кнопка — для действий. Если перепутать, поведение и доступность ухудшаются.'
  },
  {
    question: 'Какой тип у <button> внутри формы по умолчанию?',
    options: ['submit', 'button', 'reset', 'link'],
    correctAnswer: 0,
    explanation: 'По умолчанию button внутри формы является submit. Поэтому лучше явно задавать type, чтобы избежать случайной отправки.'
  },
  {
    question: 'Почему у кнопки важно явно задавать type?',
    options: [
      'Чтобы избежать случайной отправки формы, если нужен просто клик',
      'Чтобы кнопка стала доступной для скринридеров',
      'Чтобы кнопка автоматически получила aria-label',
      'Чтобы кнопка стала ссылкой'
    ],
    correctAnswer: 0,
    explanation: 'Явный type предотвращает неожиданный submit. Доступность и aria‑label зависят от текста и структуры, а не от type.'
  },
  {
    question: 'Зачем нужен label у поля формы?',
    options: [
      'Он связывает поле и подпись, улучшая доступность',
      'Он заменяет атрибут name при отправке',
      'Он делает поле обязательным',
      'Он отключает автозаполнение'
    ],
    correctAnswer: 0,
    explanation: 'Label объясняет, что вводить, и делает поле доступным. Он не заменяет name и не управляет обязательностью.'
  },
  {
    question: 'Что произойдёт, если у поля нет name?',
    options: [
      'Его значение не будет отправлено вместе с формой',
      'Поле станет недоступным для клавиатуры',
      'Поле автоматически получит значение из placeholder',
      'Поле станет обязательным'
    ],
    correctAnswer: 0,
    explanation: 'Отправка формы строится по парам name=value, поэтому без name данные не уйдут. Доступность и обязательность от этого не зависят.'
  },
  {
    question: 'Какой тип input подходит для email?',
    options: ['email', 'text', 'mail', 'address'],
    correctAnswer: 0,
    explanation: 'type="email" включает базовую проверку формата и подходящую клавиатуру на мобильных. Остальные варианты не дают этих преимуществ.'
  },
  {
    question: 'Зачем нужен alt у изображений?',
    options: [
      'Чтобы описать смысл изображения для тех, кто его не видит',
      'Чтобы автоматически сжать картинку',
      'Чтобы запретить копирование изображения',
      'Чтобы сделать картинку фоном'
    ],
    correctAnswer: 0,
    explanation: 'Alt — текстовое описание для доступности и случая, если картинка не загрузилась. Он не сжимает изображение и не управляет копированием.'
  },
  {
    question: 'Что делает loading="lazy"?',
    options: [
      'Откладывает загрузку изображения до появления в зоне видимости',
      'Автоматически уменьшает размер файла',
      'Запрещает показывать изображение',
      'Делает изображение фоном'
    ],
    correctAnswer: 0,
    explanation: 'Lazy‑loading улучшает производительность, загружая изображения только когда они нужны. Он не меняет размер файла и не скрывает изображение.'
  },
  {
    question: 'Почему нельзя вкладывать div внутрь p?',
    options: [
      'Это невалидная структура и может ломать отображение',
      'Это приводит к отключению JavaScript',
      'Это ускоряет загрузку, поэтому запрещено',
      'Это автоматически скрывает текст'
    ],
    correctAnswer: 0,
    explanation: '<p> предназначен только для текста и inline‑элементов, поэтому блочные теги внутри него невалидны. Это может приводить к неожиданному поведению браузера.'
  },
  {
    question: 'Какой пример является невалидной вложенностью?',
    options: [
      '<p><div>Текст</div></p>',
      '<div><p>Текст</p></div>',
      '<section><h2>Заголовок</h2></section>',
      '<ul><li>Пункт</li></ul>'
    ],
    correctAnswer: 0,
    explanation: 'Блочный div внутри p нарушает правила HTML. Остальные варианты являются корректными структурами.'
  },
  {
    question: 'Что даёт атрибут defer у скрипта?',
    options: [
      'Он не блокирует разбор HTML и выполняется после парсинга',
      'Он делает скрипт невидимым для браузера',
      'Он добавляет скрипт в head автоматически',
      'Он отключает CSS‑файлы'
    ],
    correctAnswer: 0,
    explanation: 'defer позволяет загрузить скрипт, не блокируя HTML, и выполнить его позже. Он не скрывает скрипт и не влияет на CSS.'
  },
  {
    question: 'Что такое progressive enhancement (прогрессивное улучшение)?',
    options: [
      'Сначала базовый HTML, затем улучшения через CSS и JS',
      'Сначала сложные анимации, затем базовый HTML',
      'Полная зависимость от JavaScript без HTML‑каркаса',
      'Оптимизация изображений без изменения разметки'
    ],
    correctAnswer: 0,
    explanation: 'Прогрессивное улучшение означает, что базовая функциональность доступна сразу, а улучшения добавляются сверху. Это делает страницу устойчивой.'
  },
  {
    question: 'Что означает термин deprecated в HTML?',
    options: [
      'Тег или атрибут устарели и не рекомендуются к использованию',
      'Тег автоматически оптимизируется браузером',
      'Тег нужен только для мобильных устройств',
      'Тег можно использовать без закрытия'
    ],
    correctAnswer: 0,
    explanation: 'Deprecated означает, что элемент устарел и лучше заменить современными решениями. Он не оптимизируется автоматически и не предназначен только для мобильных.'
  },
  {
    question: 'Зачем проверять HTML валидатором?',
    options: [
      'Чтобы найти ошибки разметки и улучшить стабильность',
      'Чтобы автоматически добавить CSS‑стили',
      'Чтобы ускорить работу базы данных',
      'Чтобы заменить семантические теги на div'
    ],
    correctAnswer: 0,
    explanation: 'Валидация помогает обнаружить ошибки вложенности и пропущенные атрибуты. Она не добавляет стили и не связана с базой данных.'
  },
  {
    question: 'Почему важно использовать семантический каркас (header, main, footer)?',
    options: [
      'Он делает структуру страницы понятной и доступной',
      'Он автоматически создаёт сетку и стили',
      'Он заменяет необходимость в заголовках',
      'Он отключает необходимость в alt‑тексте'
    ],
    correctAnswer: 0,
    explanation: 'Семантический каркас описывает структуру и помогает навигации. Он не создаёт стили и не отменяет другие требования доступности.'
  },
  {
    question: 'Зачем задавать lang у тега html?',
    options: [
      'Чтобы браузер и ассистивные технологии знали язык страницы',
      'Чтобы автоматически добавить перевод страницы',
      'Чтобы увеличить размер шрифта',
      'Чтобы скрыть страницу от поиска'
    ],
    correctAnswer: 0,
    explanation: 'lang помогает скринридерам и поиску правильно интерпретировать контент. Он не переводит страницу автоматически и не влияет на индексацию напрямую.'
  },
  {
    question: 'Почему нельзя отправлять форму ссылкой <a href="#">?',
    options: [
      'Ссылка не соответствует действию формы, нужна кнопка submit',
      'Ссылка всегда ломает валидацию HTML',
      'Ссылка автоматически добавляет aria-hidden',
      'Ссылка запрещает ввод текста в поле'
    ],
    correctAnswer: 0,
    explanation: 'Отправка формы — действие, поэтому нужна кнопка. Ссылка предназначена для навигации и создаёт неправильную семантику.'
  },
  {
    question: 'В каком случае лучше использовать кнопку вместо ссылки?',
    options: [
      'Когда нужно открыть модальное окно или выполнить действие на странице',
      'Когда нужно перейти на другую страницу',
      'Когда нужно добавить SEO‑ключевые слова',
      'Когда нужно изменить размер шрифта'
    ],
    correctAnswer: 0,
    explanation: 'Кнопка подходит для действий без перехода, например открыть фильтры или модалку. Для переходов на другую страницу нужна ссылка.'
  },
  {
    question: 'Почему несколько h1 считаются плохой практикой в учебных проектах?',
    options: [
      'Это усложняет структуру и делает страницу менее понятной',
      'Это запрещено всеми браузерами',
      'Это автоматически ломает CSS‑сетки',
      'Это делает страницу невидимой для поиска'
    ],
    correctAnswer: 0,
    explanation: 'Один главный заголовок делает структуру ясной и предсказуемой. Хотя HTML допускает несколько h1, в учебных проектах лучше придерживаться одного.'
  },
  {
    question: 'Какой вариант правильный для отправки формы?',
    options: [
      '<button type="submit">Отправить</button>',
      '<a href="#">Отправить</a>',
      '<div role="button">Отправить</div>',
      '<span>Отправить</span>'
    ],
    correctAnswer: 0,
    explanation: 'Кнопка submit соответствует действию формы и корректно работает с клавиатурой. Остальные варианты не дают правильной семантики.'
  },
  {
    question: 'Почему важна корректная вложенность элементов?',
    options: [
      'Невалидная структура может ломать отображение и доступность',
      'Она влияет только на скорость интернета',
      'Она нужна только для анимаций',
      'Она не влияет ни на что в современных браузерах'
    ],
    correctAnswer: 0,
    explanation: 'Правильная вложенность делает HTML предсказуемым для браузера и ассистивных технологий. Ошибки могут приводить к неожиданным результатам.'
  },
  {
    question: 'Какое утверждение соответствует best practices для форм?',
    options: [
      'Каждое поле имеет label, name и корректный type',
      'Label можно заменить placeholder, если текст короткий',
      'Name нужен только для стилизации',
      'Type можно не задавать, браузер сам решит'
    ],
    correctAnswer: 0,
    explanation: 'Label, name и type — базовые элементы понятной и рабочей формы. Placeholder не заменяет label, а браузер не всегда подберёт корректный тип.'
  }
];

async function upsertQuestions({ testTitle, lectureTitle, questions }) {
  const test = await prisma.test.findFirst({ where: { title: testTitle } });
  if (!test) throw new Error(`Test not found: ${testTitle}`);

  const lecture = await prisma.lecture.findFirst({ where: { title: lectureTitle } });
  if (!lecture) throw new Error(`Lecture not found: ${lectureTitle}`);

  const maxOrder = await prisma.testQuestion.findFirst({
    where: { testId: test.id },
    orderBy: { order: 'desc' },
    select: { order: true }
  });

  let nextOrder = (maxOrder?.order || 0) + 1;

  for (const q of questions) {
    const existing = await prisma.question.findFirst({ where: { question: q.question } });
    let questionId;

    if (existing) {
      const updated = await prisma.question.update({
        where: { id: existing.id },
        data: {
          options: q.options,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation,
          lectureId: lecture.id
        }
      });
      questionId = updated.id;
      console.log(`updated: ${q.question}`);
    } else {
      const created = await prisma.question.create({
        data: {
          question: q.question,
          options: q.options,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation,
          lectureId: lecture.id
        }
      });
      questionId = created.id;
      console.log(`created: ${q.question}`);
    }

    const linkExists = await prisma.testQuestion.findFirst({
      where: { testId: test.id, questionId }
    });

    if (!linkExists) {
      await prisma.testQuestion.create({
        data: {
          testId: test.id,
          questionId,
          order: nextOrder++
        }
      });
      console.log(`linked: ${testTitle} -> ${questionId}`);
    }
  }
}

async function main() {
  await upsertQuestions({
    testTitle: 'HTML: доступность и ARIA основы',
    lectureTitle: 'HTML: доступность и ARIA основы',
    questions: accessibilityQuestions
  });

  await upsertQuestions({
    testTitle: 'HTML: метаданные и SEO',
    lectureTitle: 'HTML: метаданные и SEO',
    questions: metadataQuestions
  });

  await upsertQuestions({
    testTitle: 'HTML: best practices и типичные ошибки',
    lectureTitle: 'HTML: best practices и типичные ошибки',
    questions: bestPracticesQuestions
  });
}

main()
  .catch((error) => {
    console.error('Error:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    await pool.end();
  });
