import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';
import dotenv from 'dotenv';
import path from 'path';

const envPath = path.resolve(__dirname, '..', '.env');
dotenv.config({ path: envPath });

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

const lectureContent = `# Требования к безопасности (Security Requirements)

## Введение: как пропуска в офисе 🏢

Представьте офис без пропусков. Любой может зайти в серверную,
никто не знает, кто отвечает за инциденты и где лежат резервные копии.
Красиво и удобно — но небезопасно.

**Безопасность в ПО — это не «желательно», а конкретные правила.**
И эти правила называются требованиями к безопасности.

💡 **Совет:** думайте о безопасности как о контракте: кто, что, от чего и как защищаем.

---

## Что такое требования к безопасности

**Security Requirements** — это измеримые условия, которые защищают данные,
пользователей и систему от угроз и злоупотреблений.

Они нужны, чтобы:
- заранее договориться о правилах защиты,
- снизить риски и ущерб,
- сделать безопасность проверяемой, а не «на глаз».

✅ **Вывод:** безопасность должна быть конкретной и проверяемой, иначе это не требование.

---

## Базовые понятия

### CIA triad

- **Confidentiality (конфиденциальность)** — доступ только для тех, кому разрешено.
- **Integrity (целостность)** — данные нельзя изменить незаметно.
- **Availability (доступность)** — сервис работает, когда нужен.

💡 **Совет:** если требование не связано хотя бы с одним из этих пунктов,
значит оно описано слишком абстрактно.

### Угроза, уязвимость, риск

- **Threat (угроза)** — потенциальная атака.
- **Vulnerability (уязвимость)** — слабое место, через которое атакуют.
- **Risk (риск)** — вероятность × ущерб.

Пример: открытая админка — уязвимость,
боты-сканеры — угроза,
утечка базы — риск.

✅ **Вывод:** сначала выявляем угрозы, потом закрываем уязвимости, уменьшая риск.

---

## Как формулировать security requirements

Хорошее требование отвечает на 4 вопроса:

1) **Что защищаем** (данные, процесс, сервис)
2) **От чего защищаем** (угроза, злоупотребление)
3) **Как защищаем** (контроль, механизм)
4) **Как проверяем** (метрика, критерий)

Пример:

\`\`\`
Все персональные данные шифруются AES-256 at rest.
Передача данных — только по TLS 1.2+.
Проверка: автоматический аудит конфигурации перед релизом.
\`\`\`

💡 **Совет:** если нельзя написать тест — требование неполное.

---

## Контроль доступа: кто и что может

### Authentication vs Authorization

**Authentication (аутентификация)** отвечает на «кто ты».  
**Authorization (авторизация)** отвечает на «что тебе можно».

Если перепутать — роли и доступы настраиваются неверно.

### Principle of Least Privilege

Пользователь получает **минимум прав**, достаточный для задачи.

Пример:
- Менеджер видит сводные отчёты.
- Финансовые детали доступны только роли Финансы.

✅ **Вывод:** меньше прав = меньше ущерба при ошибке или взломе.

### MFA и step-up MFA

**MFA** снижает риск взлома, даже если пароль утёк.
Если бизнесу нужна простая регистрация —
используем **step-up MFA** для рискованных действий.

💡 **Совет:** компромисс важнее крайностей.

---

## Сессии и токены

- Access token должен иметь короткий срок жизни.
- Refresh token должен быть отзывным.
- При смене пароля активные сессии нужно отзывать.

**JWT** — подписанный токен, но **не шифрует данные**.
Секреты в него не кладём.

**OAuth 2.0** — протокол делегированной авторизации.

✅ **Вывод:** безопасность токенов — это сроки, отзыв и минимальные данные.

---

## Пароли и хранение данных

Пароль **нельзя хранить в открытом виде**.
Нужно использовать хеширование и соль:
- bcrypt
- Argon2id

Если звучит фраза «bcrypt слишком медленный»,
это не повод убрать хеширование. Нужно:
- измерить нагрузку,
- подобрать cost factor,
- зафиксировать метрики в требованиях.

Пример:
\`\`\`
SEC-PW-01: Пароли хешируются bcrypt (cost=12) или Argon2id.
SEC-PW-02: p95 время входа ≤ 300ms при 50 RPS.
\`\`\`

💡 **Совет:** скорость настраивают параметрами, безопасность не выкидывают.

---

## Шифрование

- **Encryption in Transit** — защита канала (HTTPS/TLS).
- **Encryption at Rest** — защита хранения (AES-256).

**TLS 1.2+** — минимальная версия для продакшена.

✅ **Вывод:** шифрование должно быть и в канале, и в хранении.

---

## Типовые уязвимости (OWASP Top 10)

OWASP Top 10 помогает не забыть самые частые классы атак.

- **SQL Injection** → защита: параметризованные запросы.
- **XSS** → защита: экранирование + CSP.
- **CSRF** → защита: CSRF-токены, sameSite cookies.
- **Security Misconfiguration** → защита: безопасные конфиги, запрет дефолтных паролей.

💡 **Совет:** OWASP — это чек-лист, а не теория.

---

## Защита от злоупотреблений

Часто спрашивают, для чего нужен rate limiting.
Он ограничивает частоту запросов, снижает риск перебора пароля и DoS.

Пример:
\`\`\`
Не более 100 запросов в минуту на пользователя.
После 5 неудачных попыток — временная блокировка.
\`\`\`

✅ **Вывод:** rate limiting — это защита от злоупотреблений и перегрузки.

---

## Security Headers

Заголовки задают правила для браузера:
- **HSTS** — запрет HTTP
- **CSP** — политика источников контента
- **X-Frame-Options** — защита от clickjacking
- **X-Content-Type-Options** — защита от MIME sniffing

💡 **Совет:** заголовки — дешёвая, но сильная защита.

---

## Логи и аудит

Security audit logs нужны для расследований и комплаенса.
Они должны быть неизменяемыми и иметь срок хранения.

Пример:
\`\`\`
Audit-логи неизменяемы и хранятся 90 дней.
Доступ к логам только у Security/Compliance.
\`\`\`

✅ **Вывод:** без логов нет расследований и доверия.

---

## Процессы безопасности

- **SSDLC (Secure SDLC)** — безопасность на всех этапах разработки.
- **Threat Modeling** — выявляет угрозы и превращает их в требования.
- **Penetration Testing** — ручная имитация атаки.
- **Vulnerability Scanning** — автоматический поиск уязвимостей.

💡 **Совет:** процесс важнее разовой проверки.

---

## Приоритизация и компромиссы

При ограниченном бюджете закрывают:
1) критичные риски
2) обязательные нормы
3) остальное — в бэклог

Если конфликтует удобство и безопасность:
используем **step-up MFA** или ограничение по рисковым операциям.

✅ **Вывод:** безопасность — это баланс между риском и удобством.

---

## Заключение

Требования к безопасности превращают «быть безопасным» в конкретные правила.
Они объясняют **как**, **почему** и **зачем** мы защищаем систему.

### Ключевые мысли

- 🎯 Требования должны быть измеримыми и проверяемыми.
- 🎯 OWASP Top 10 и threat modeling дают основу покрытия.
- 🎯 Логи, шифрование и контроль доступа — базовый минимум.
- 🎯 Баланс между безопасностью и удобством решается через компромисс.
`;

const scenariosContent = `## Популярные сценарии

### Сценарий 1: Слишком общее требование

❌ **Неправильно**:  
"Система должна быть безопасной".

✅ **Правильно**:  
"Все PII шифруются AES-256 at rest, передача по TLS 1.2+".

**Почему:** есть метрики и проверка.

**Практический пример:**
\`\`\`
SEC-01: PII шифруются AES-256 at rest.
SEC-02: Передача данных только по TLS 1.2+.
SEC-03: Аудит конфигурации перед релизом.
\`\`\`

### Сценарий 2: Доступ к отчётам

❌ **Неправильно**:  
"Менеджер видит все отчёты".

✅ **Правильно**:  
"Менеджер видит сводные отчёты, финансы доступны только роли Finance".

**Почему:** принцип least privilege.

**Практический пример:**
\`\`\`
REQ-AC-01: Manager видит только сводные отчёты.
REQ-AC-02: Финансовые детали доступны роли Finance.
\`\`\`

### Сценарий 3: Пароли

❌ **Неправильно**:  
"Пароли шифруем".

✅ **Правильно**:  
"Пароли хешируются bcrypt (cost=12) + соль".

**Почему:** шифрование и хеширование — разные вещи.

**Практический пример:**
\`\`\`
SEC-PW-01: bcrypt (cost=12) + соль.
SEC-PW-02: пересмотр параметров раз в квартал.
\`\`\`

### Сценарий 4: MFA vs удобство

❌ **Неправильно**:  
"MFA всегда и для всех действий".

✅ **Правильно**:  
"MFA только для входа с нового устройства и платежей".

**Почему:** компромисс между UX и риском.

**Практический пример:**
\`\`\`
SEC-MFA-01: MFA при входе с нового устройства.
SEC-MFA-02: MFA для платежей выше 100$.
\`\`\`

### Сценарий 5: Срок жизни токенов

❌ **Неправильно**:  
"Токены живут бесконечно".

✅ **Правильно**:  
"Access token 15 минут, refresh token 7 дней".

**Почему:** снижает последствия кражи токена.

**Практический пример:**
\`\`\`
SEC-SESSION-01: Access token 15 минут.
SEC-SESSION-02: Refresh token 7 дней.
\`\`\`

### Сценарий 6: CSRF

❌ **Неправильно**:  
"POST-запросы без защиты".

✅ **Правильно**:  
"CSRF-токен + sameSite cookies для всех state-changing запросов".

**Почему:** защищает от подмены запросов.

**Практический пример:**
\`\`\`
SEC-CSRF-01: CSRF-токены для POST/PUT/PATCH/DELETE.
SEC-CSRF-02: sameSite cookies = Lax/Strict.
\`\`\`

### Сценарий 7: Логи

❌ **Неправильно**:  
"Логи пишем по необходимости".

✅ **Правильно**:  
"Audit-логи неизменяемы и хранятся 90 дней".

**Почему:** нужны расследования и комплаенс.

**Практический пример:**
\`\`\`
SEC-AUDIT-01: Логи входа/выхода и админ-действий неизменяемы.
SEC-AUDIT-02: Хранение 90 дней.
\`\`\`

### Сценарий 8: Rate limiting

❌ **Неправильно**:  
"Нет ограничений по частоте запросов".

✅ **Правильно**:  
"Не более 100 запросов в минуту, блокировка при аномалиях".

**Почему:** защита от брутфорса и перегрузки.

**Практический пример:**
\`\`\`
SEC-RATE-01: 100 запросов в минуту на пользователя.
SEC-RATE-02: блокировка на 15 минут после 5 ошибок.
\`\`\`

### Сценарий 9: Security headers

❌ **Неправильно**:  
"Заголовки безопасности не обязательны".

✅ **Правильно**:  
"HSTS, CSP, X-Frame-Options включены по умолчанию".

**Почему:** уменьшают риск XSS и clickjacking.

**Практический пример:**
\`\`\`
SEC-HDR-01: HSTS включён.
SEC-HDR-02: CSP запрещает inline-скрипты.
\`\`\`

### Сценарий 10: Data retention

❌ **Неправильно**:  
"Храним данные всегда".

✅ **Правильно**:  
"PII удаляется через 24 месяца после последней активности".

**Почему:** снижает риск и соответствует нормам.

**Практический пример:**
\`\`\`
SEC-RET-01: PII удаляется через 24 месяца.
SEC-RET-02: Удаление фиксируется в журнале.
\`\`\`
`;

const exampleContent = `## Пример: фрагмент документа требований безопасности 📄

Разрабатывается условно такой сайт: маркетплейс с оплатой картой и личным кабинетом.  
После всех митингов, общения с бизнесом и постановки задачи стало ясно,  
что главная проблема — риск утечки данных и злоупотреблений при входе и оплате.  
Ниже — реальный фрагмент документа, который фиксирует требования.

---

### Security Requirements — Payment Service

**Scope:** API оплаты, обработка карт, личный кабинет пользователя.  
**Assets:** PII, платежные данные, история транзакций.  
**Threats:** перебор паролей, SQL Injection, утечка PII, компрометация токенов.

#### Требования

**SEC-AUTH-01**: Вход в аккаунт требует MFA при новом устройстве.  
**SEC-AUTH-02**: Access token 15 минут, refresh token 7 дней, отзыв при смене пароля.  
**SEC-PW-01**: Пароли хешируются bcrypt (cost=12) + соль.  
**SEC-TLS-01**: Все запросы только по TLS 1.2+, HTTP запрещен.  
**SEC-PII-01**: PII шифруется AES-256 at rest.  
**SEC-RATE-01**: Rate limit 100 req/min на пользователя, блокировка после 5 ошибок.  
**SEC-AUDIT-01**: Audit-логи неизменяемы и хранятся 90 дней.

#### Проверка (Acceptance)

- ✅ Авто-тест подтверждает отсутствие HTTP.  
- ✅ Набор тестов проверяет сроки жизни токенов.  
- ✅ Логи аудита доступны только Security/Compliance.  
- ✅ Threat modeling документирован и пересматривается раз в квартал.

💡 **Совет:** такой формат легко проверять и поддерживать в актуальном состоянии.
`;

async function createSecurityRequirementsLecture() {
  try {
    console.log('🚀 Создание лекции "Требования к безопасности (Security Requirements)"...\n');

    await prisma.lecture.deleteMany({
      where: { title: 'Требования к безопасности (Security Requirements)' }
    });

    const lecture = await prisma.lecture.create({
      data: {
        title: 'Требования к безопасности (Security Requirements)',
        topic: 'Требования к ПО',
        content: lectureContent,
        scenariosContent,
        exampleContent
      }
    });

    console.log(`✅ Лекция создана с ID: ${lecture.id}`);
  } catch (error) {
    console.error('❌ Ошибка:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
    await pool.end();
  }
}

createSecurityRequirementsLecture();

