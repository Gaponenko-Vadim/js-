import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';
import dotenv from 'dotenv';
import path from 'path';

const envPath = path.resolve(__dirname, '..', '.env');
dotenv.config({ path: envPath });

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

const lectureContent = `# HTML: текст и семантика

## Введение: текст как дорожные знаки 🧭

Представьте город без указателей. Дороги есть, но непонятно, где музей, где больница и где выход.  
Так же и на странице: **семантика текста** объясняет смысл каждого блока.

💡 Совет: думайте о тексте как о структуре, а не только о внешнем виде.
✅ Вывод: семантика помогает людям и поиску понимать страницу одинаково.

---

## Что такое семантика текста

**Семантика** — это смысл, который вы вкладываете в разметку.  
Она говорит, что перед нами: заголовок, абзац, цитата, список или дата.

🎯 Главное: CSS меняет внешний вид, а семантика объясняет значение.

---

## Заголовки: каркас текста

Заголовки строят иерархию:
- H1 — главный заголовок страницы
- H2 — разделы
- H3 — подразделы

Небольшой пример:

~~~html
<h1>Текст и семантика</h1>
<h2>Заголовки</h2>
<h3>Порядок уровней</h3>
~~~

⚠️ Важно: уровни не перескакивают (H1 → H2 → H3).

💡 Совет: один H1 на страницу — это чёткий ориентир для читателя.
✅ Вывод: правильная иерархия делает текст читаемым и логичным.

---

## Абзацы, переносы и разделители

- **<p>** — завершённая мысль (абзац)
- **<br>** — перенос строки внутри одной мысли
- **<hr>** — смысловое разделение тем

Небольшой пример:

~~~html
<p>Это законченная мысль.</p>
<br />
<hr />
~~~

💡 Совет: новый смысл = новый абзац, а не перенос строки.
✅ Вывод: p, br и hr решают разные задачи и не заменяют друг друга.

---

## Выделение смысла

- **<strong>** — смысловое усиление важности
- **<em>** — смысловой акцент
- **<b>** и **<i>** — только визуальный стиль

Небольшой пример:

~~~html
<strong>Важно:</strong> сохраните изменения.
<em>Именно этот шаг</em> обязателен.
~~~

⚠️ Важно: если смысл важен, используйте strong или em.
✅ Вывод: семантическое выделение полезно для доступности и SEO.

---

## Списки как структура

- **<ul>** — список без порядка
- **<ol>** — список шагов
- **<dl>** — термины и определения

Небольшой пример:

~~~html
<ul><li>Пункт</li></ul>
<ol><li>Шаг 1</li></ol>
<dl><dt>Термин</dt><dd>Определение</dd></dl>
~~~

💡 Совет: списки нужны для структуры, а не для отступов.
✅ Вывод: список = смысл, а не декоративный элемент.

---

## Цитаты и источники

- **<blockquote>** — большая цитата
- **<q>** — короткая цитата внутри предложения
- **<cite>** — источник цитаты

Небольшой пример:

~~~html
<blockquote>Хорошая структура делает текст сильнее.</blockquote>
<cite>Редактор блога</cite>
~~~

💡 Совет: цитату оформляем как цитату, а не как обычный абзац.
✅ Вывод: правильные теги передают смысл и уважают автора.

---

## Технический текст

- **<code>** — фрагмент кода в тексте
- **<pre>** — блок кода с сохранением форматирования
- **<kbd>** — ввод с клавиатуры
- **<samp>** — вывод программы

Небольшой пример:

~~~html
<code>&lt;p&gt;Абзац&lt;/p&gt;</code>
<kbd>Ctrl</kbd> + <kbd>S</kbd>
~~~

💡 Совет: технический текст должен отличаться от обычного.
✅ Вывод: правильные теги делают инструкции и код понятнее.

---

## Время, сокращения и индексы

- **<time datetime="...">** — дата и время
- **<abbr title="...">** — сокращение с расшифровкой
- **<sub> / <sup>** — нижние и верхние индексы

Небольшой пример:

~~~html
<time datetime="2026-02-10">10 февраля 2026</time>
<abbr title="Application Programming Interface">API</abbr>
H<sub>2</sub>O и m<sup>2</sup>
~~~

✅ Вывод: точные теги помогают людям и машинам читать текст одинаково.

---

## Div и span — нейтральные контейнеры

**<div>** и **<span>** не несут смысла. Это просто оболочки.  
Используйте их, когда нет подходящего семантического тега.

Небольшой пример:

~~~html
<div class="card"><span>Подпись</span></div>
~~~

💡 Совет: если есть p, ul, strong или blockquote — лучше использовать их.
✅ Вывод: семантика важнее универсальных контейнеров.

---

## Footer как смысловое завершение

**<footer>** — финальная информация блока или страницы: контакты, автор, ссылки.  
Footer можно ставить как внизу страницы, так и внутри статьи.

Небольшой пример:

~~~html
<footer>Контакты и автор</footer>
~~~

✅ Вывод: footer — это не просто низ, а смысловое завершение блока.

---

## Семантика = доступность и поиск

Читатели и скринридеры опираются на заголовки, списки и абзацы.  
Поисковые системы лучше понимают структуру текста.

💡 Совет: если текст понятен скринридеру, он понятен всем.

---

## Типичные ошибки

1) Абзацы через <br> — теряется смысловая структура.
2) Списки ради отступов — список перестаёт быть списком.
3) <b> вместо <strong> — смысл важности теряется.
4) Заголовки без порядка — ломается логика чтения.
5) Дата без <time> — машина не понимает дату.
6) Цитата как обычный текст — теряется авторство.

---

## Best Practices

- Один H1 на страницу
- Новая мысль = новый абзац
- Используйте strong и em для смысла
- Списки только по назначению
- Цитаты оформляйте корректно
- Даты и сокращения всегда размечайте

✅ Вывод: семантика экономит время и улучшает качество текста.

---

## Заключение

Семантика текста — это язык, на котором вы объясняете смысл страницы.  
Она делает контент понятным людям, поиску и вспомогательным технологиям.

### Ключевые мысли

🎯 Заголовки строят логику текста  
🎯 Абзацы и списки передают смысл  
🎯 Семантические теги делают текст доступным

💪 Продолжайте практиковаться — каждый правильный тег делает вашу разметку сильнее.
`;

const scenariosContent = `## Популярные сценарии

### Сценарий 1: Абзацы через <br>

❌ **Неправильно**: переносы строк вместо абзацев.  
✅ **Правильно**: каждая мысль — отдельный абзац.

**Почему**: абзац обозначает логическую завершённость, а <br> — лишь перенос строки.

**Практический пример:**
DOC-01: Каждый логический блок описания оформляется отдельным абзацем.

---

### Сценарий 2: Важное слово выделяют <b>

❌ **Неправильно**: выделение важности только визуально.  
✅ **Правильно**: использовать <strong> для смыслового акцента.

**Почему**: семантическое выделение читают и люди, и скринридеры.

**Практический пример:**
REQ-03: Все предупреждения в инструкции должны иметь смысловой акцент.

---

### Сценарий 3: Список ради отступов

❌ **Неправильно**: список используется как способ сделать отступы.  
✅ **Правильно**: списки только для перечней, отступы — через стили.

**Почему**: список должен передавать структуру, а не внешний вид.

**Практический пример:**
DOC-04: Перечни требований оформляются списком, обычный текст — абзацами.

---

### Сценарий 4: Термин без расшифровки

❌ **Неправильно**: сокращение без пояснения.  
✅ **Правильно**: использовать <abbr> с атрибутом title.

**Почему**: читатель и ассистенты должны понимать значение сокращения.

**Практический пример:**
REQ-06: При первом упоминании термина даётся расшифровка.

---

### Сценарий 5: Дата без <time>

❌ **Неправильно**: дата просто в тексте.  
✅ **Правильно**: дата размечена тегом <time>.

**Почему**: так дату понимают люди и программы.

**Практический пример:**
DOC-07: Все даты релизов должны быть машинно читаемыми.

---

### Сценарий 6: Цитату пишут как абзац

❌ **Неправильно**: цитата оформлена обычным текстом.  
✅ **Правильно**: использовать <blockquote> и <cite>.

**Почему**: цитата должна быть отделена и иметь источник.

**Практический пример:**
DOC-09: Отзывы клиентов оформляются как цитаты с указанием автора.

---

### Сценарий 7: Комбинации клавиш без <kbd>

❌ **Неправильно**: команда клавиатуры как обычный текст.  
✅ **Правильно**: использовать <kbd> для комбинаций.

**Почему**: так читатель сразу видит, что это ввод.

**Практический пример:**
DOC-10: Все сочетания клавиш выделяются как клавиатурный ввод.

---

### Сценарий 8: Код без семантики

❌ **Неправильно**: код в тексте как обычные слова.  
✅ **Правильно**: использовать <code> или <pre>.

**Почему**: код должен быть визуально и смыслово выделен.

**Практический пример:**
REQ-12: Все примеры команд представлены как кодовые блоки.

---

### Сценарий 9: Footer как общий контейнер

❌ **Неправильно**: footer используют для любых нижних блоков.  
✅ **Правильно**: footer — это завершение страницы или статьи.

**Почему**: у footer есть смысл, а не только позиция.

**Практический пример:**
DOC-14: Внизу статей указываются автор и контакты через блок завершения.
`;

const tasksContent = `## Задания для практики 🧪

### Задание 1: Иерархия заголовков
> **Ситуация:** есть статья с разделами и подразделами.  
> **Что сделать:** построить корректную иерархию заголовков.  
> **Критерий:** уровни идут по порядку, H1 один.

**Ответ:**
~~~html
<h1>Текстовая семантика</h1>
<h2>Заголовки</h2>
<h3>Порядок уровней</h3>
~~~
**Объяснение:** сначала задаём один главный H1, затем разделы H2 и подразделы H3. Это делает структуру читаемой.

---

### Задание 2: Абзацы вместо переносов
> **Ситуация:** текст разделили переносами строк.  
> **Что сделать:** заменить переносы на абзацы.  
> **Критерий:** каждая мысль оформлена отдельным <p>.

**Ответ:**
~~~html
<p>Это первая мысль текста.</p>
<p>Это новая логическая мысль.</p>
~~~
**Объяснение:** абзац — логически завершённый блок. Перенос строки не заменяет абзац.

---

### Задание 3: Смысловое выделение
> **Ситуация:** важное слово оформлено как <b>.  
> **Что сделать:** заменить на семантический тег.  
> **Критерий:** смысл важности читается даже без CSS.

**Ответ:**
~~~html
<strong>Важно:</strong> сохраните изменения перед выходом.
~~~
**Объяснение:** <strong> передаёт смысловой акцент, тогда как <b> — только стиль.

---

### Задание 4: Правильный список
> **Ситуация:** есть три шага инструкции.  
> **Что сделать:** оформить как упорядоченный список.  
> **Критерий:** шаги идут по порядку.

**Ответ:**
~~~html
<ol>
  <li>Открыть файл</li>
  <li>Внести правки</li>
  <li>Сохранить результат</li>
</ol>
~~~
**Объяснение:** если порядок важен, используйте <ol>. Для обычного перечня нужен <ul>.

---

### Задание 5: Термины и определения
> **Ситуация:** есть термин и его расшифровка.  
> **Что сделать:** оформить как список определений.  
> **Критерий:** используются <dl>, <dt>, <dd>.

**Ответ:**
~~~html
<dl>
  <dt>Семантика</dt>
  <dd>Смысловое значение элементов текста.</dd>
</dl>
~~~
**Объяснение:** <dl> предназначен для пар «термин — определение».

---

### Задание 6: Цитата и источник
> **Ситуация:** в статье есть отзыв пользователя.  
> **Что сделать:** оформить цитату и источник.  
> **Критерий:** используются <blockquote> и <cite>.

**Ответ:**
~~~html
<blockquote>Курс помог понять семантику текста.</blockquote>
<cite>Анна, студент</cite>
~~~
**Объяснение:** blockquote выделяет цитату, а cite фиксирует источник.

---

### Задание 7: Дата публикации
> **Ситуация:** нужно показать дату новости.  
> **Что сделать:** оформить дату как машинно читаемую.  
> **Критерий:** есть атрибут datetime.

**Ответ:**
~~~html
<time datetime="2026-02-10">10 февраля 2026</time>
~~~
**Объяснение:** datetime нужен для машинного чтения, а текст — для человека.

---

### Задание 8: Сокращение с расшифровкой
> **Ситуация:** встречается сокращение API.  
> **Что сделать:** добавить расшифровку.  
> **Критерий:** есть title с полным названием.

**Ответ:**
~~~html
<abbr title="Application Programming Interface">API</abbr>
~~~
**Объяснение:** abbr делает сокращение понятным читателю и ассистентам.

---

### Задание 9: Footer для статьи
> **Ситуация:** нужно завершить статью контактами автора.  
> **Что сделать:** добавить блок footer.  
> **Критерий:** footer используется как завершение статьи.

**Ответ:**
~~~html
<footer>
  <p>Автор: редакция блога</p>
  <p>Контакты: hello@blog.example</p>
</footer>
~~~
**Объяснение:** footer фиксирует финальную информацию блока или статьи, а не просто «низ» страницы.
`;

const exampleContent = `## Пример: текстовая разметка статьи 📄

Разрабатывается условно такой сайт: блог для новичков в разработке.  
После всех митингов и постановки задачи нужно было решить проблему:  
текст читается тяжело, а поисковые системы плохо понимают структуру.

Ниже — пример готовой разметки статьи с правильной семантикой.

---

~~~html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>HTML: текст и семантика</title>
  </head>
  <body>
    <article>
      <h1>HTML: текст и семантика</h1>
      <p><strong>Семантика</strong> делает текст понятным людям и поиску.</p>

      <h2>Основные элементы</h2>
      <ul>
        <li>Заголовки и абзацы</li>
        <li>Списки и цитаты</li>
        <li>Даты и сокращения</li>
      </ul>

      <h2>Цитата</h2>
      <blockquote>Хорошая структура делает текст сильнее.</blockquote>
      <cite>Редактор блога</cite>

      <p>Дата публикации: <time datetime="2026-02-10">10 февраля 2026</time></p>
      <p>Термин <abbr title="Application Programming Interface">API</abbr> встречается часто.</p>

      <p>Совет: нажмите <kbd>Ctrl</kbd> + <kbd>Enter</kbd>, чтобы сохранить.</p>

      <h2>Фрагмент кода</h2>
      <pre><code>&lt;p&gt;Новый абзац&lt;/p&gt;</code></pre>

      <footer>
        <p>Автор: редакция блога</p>
        <p>Контакты: hello@blog.example</p>
      </footer>
    </article>
  </body>
</html>
~~~
`;

async function createHtmlTextSemanticsLecture() {
  try {
    console.log('🚀 Пересоздание лекции "HTML: текст и семантика"...\n');

    await prisma.lecture.deleteMany({
      where: { title: 'HTML: текст и семантика' }
    });

    const lecture = await prisma.lecture.create({
      data: {
        title: 'HTML: текст и семантика',
        topic: 'HTML',
        content: lectureContent,
        scenariosContent,
        exampleContent,
        tasksContent
      }
    });

    const test = await prisma.test.findFirst({
      where: { title: 'HTML: текст и семантика' },
      include: { questions: true }
    });

    if (test) {
      for (const tq of test.questions) {
        await prisma.question.update({
          where: { id: tq.questionId },
          data: { lectureId: lecture.id }
        });
      }
      console.log(`✅ Привязано вопросов: ${test.questions.length}`);
    } else {
      console.log('⚠️ Тест не найден, вопросы не привязаны');
    }

    console.log(`✅ Лекция создана с ID: ${lecture.id}`);
  } catch (error) {
    console.error('❌ Ошибка:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
    await pool.end();
  }
}

createHtmlTextSemanticsLecture();
