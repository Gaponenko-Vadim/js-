import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';
import dotenv from 'dotenv';
import path from 'path';

dotenv.config({ path: path.resolve(process.cwd(), '.env') });

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

const TEST_TITLE = 'HTML: текст и семантика';
const TEST_DESCRIPTION =
  'Смысловая разметка текста: заголовки, абзацы, выделения, списки, цитаты, код, даты и нейтральные контейнеры.';
const TEST_DIFFICULTY = 'beginner';
const TEST_TAGS = ['frontend', 'fullstack', 'qa-engineer'];

const CATEGORY_SLUG = 'html-css';
const CATEGORY_ORDER = 2;

const questions = [
  {
    question: 'Что означает семантика текста в HTML?',
    options: [
      'Разметка передает роль текста и помогает понять, что перед нами: заголовок или абзац.',
      'Разметка описывает только визуальный стиль текста, не влияя на смысл блоков.',
      'Разметка определяет правила работы сервера и хранение данных страницы.',
      'Разметка задаёт порядок загрузки скриптов и логику взаимодействий.'
    ],
    correctAnswer: 0,
    explanation:
      'Семантика отвечает за смысл и роль текста, а не за его оформление. Визуальный стиль задаёт CSS, а серверная логика не связана с семантической разметкой.'
  },
  {
    question: 'Зачем семантика текста полезна пользователю и поиску?',
    options: [
      'Снижает размер CSS и делает стили необязательными для страницы.',
      'Помогает людям, поиску и ассистивным технологиям понимать структуру и смысл текста.',
      'Ускоряет работу сервера за счёт уменьшения HTML и логики.',
      'Полностью заменяет JavaScript, делая страницу статичной.'
    ],
    correctAnswer: 1,
    explanation:
      'Семантика делает структуру понятной для читателей, поисковых систем и скринридеров. Она не заменяет CSS или JavaScript и не ускоряет сервер напрямую.'
  },
  {
    question: 'Как правильно выстраивать заголовки по уровням?',
    options: [
      'H1 для каждого блока, чтобы все заголовки были одинаково заметны.',
      'H3 можно ставить сразу после H1, чтобы ускорить верстку.',
      'H1 для темы страницы, H2 для разделов, H3 для подразделов.',
      'H2 используют только в footer, а H3 — в начале страницы.'
    ],
    correctAnswer: 2,
    explanation:
      'Иерархия строится последовательно: H1 → H2 → H3. Прыжки по уровням и множественные H1 ломают структуру чтения.'
  },
  {
    question: 'Сколько H1 обычно размещают на странице?',
    options: [
      'H1 ставят в каждом разделе, чтобы каждый блок имел свой заголовок.',
      'Один H1, который описывает основную тему всей страницы.',
      'H1 можно не использовать, если крупный текст уже есть в div.',
      'H1 нужен только в footer, чтобы улучшить индексацию.'
    ],
    correctAnswer: 1,
    explanation:
      'Обычно используют один H1, чтобы обозначить главную тему страницы. Несколько H1 усложняют структуру, а div не заменяет семантический заголовок.'
  },
  {
    question: 'Когда использовать <p>, а когда <br>?',
    options: [
      'br — новый абзац, p — только для названий разделов.',
      'p — перенос строк, br — разделитель тем и частей статьи.',
      'br — для списков, p — для декоративных отступов текста.',
      'p — новая мысль, br — перенос строки внутри одной мысли.'
    ],
    correctAnswer: 3,
    explanation:
      'Абзац обозначает завершённую мысль, поэтому используется p. br нужен только для переноса строки внутри одного абзаца.'
  },
  {
    question: 'Что обозначает <hr> в тексте?',
    options: [
      'Декоративную линию без смысловой роли, только для красоты.',
      'Смысловой разделитель между темами или блоками текста.',
      'Перенос строки внутри абзаца, когда места не хватает.',
      'Границу таблицы или списка с автоматической нумерацией.'
    ],
    correctAnswer: 1,
    explanation:
      'hr — это тематический разделитель, который отделяет смысловые части текста. Он не заменяет перенос строки и не относится к таблицам.'
  },
  {
    question: 'Какой тег использовать для смыслового усиления важности?',
    options: [
      '<b> потому что жирный текст автоматически считается наиболее важным.',
      '<i> так как курсив подчёркивает важность лучше обычного текста.',
      '<strong> для смысловой важности, которую учитывают ассистенты и поиск.',
      '<span> чтобы универсально выделить любое слово без значения.'
    ],
    correctAnswer: 2,
    explanation:
      'strong передает смысловую важность, и её читают ассистивные технологии. b и i дают лишь визуальный стиль, а span не несет семантики.'
  },
  {
    question: 'Какой тег использовать для смыслового акцента в фразе?',
    options: [
      '<em> для смыслового акцента внутри фразы и изменения интонации.',
      '<i> потому что курсив всегда означает смысловой акцент.',
      '<b> так как жирный текст лучше подходит для акцентов.',
      '<div> чтобы вынести акцент в отдельный блок текста.'
    ],
    correctAnswer: 0,
    explanation:
      'em задает смысловое ударение, которое важно для чтения и доступности. i и b — визуальные стили, а div — контейнер без семантики.'
  },
  {
    question: 'Чем <b>/<i> отличаются от <strong>/<em>?',
    options: [
      '<b>/<i> семантичны, <strong>/<em> используются только для декора.',
      '<b>/<i> меняют вид, <strong>/<em> передают смысловую роль.',
      '<b>/<i> для списков, <strong>/<em> только для таблиц.',
      '<b>/<i> запрещены в HTML5, <strong>/<em> заменяют все теги.'
    ],
    correctAnswer: 1,
    explanation:
      'b и i дают визуальный эффект, но не смысл. strong и em несут семантику и помогают доступности, поэтому они предпочтительнее.'
  },
  {
    question: 'Когда использовать <ol>, а когда <ul>?',
    options: [
      'ul — для шагов, ol — для обычного перечня без порядка.',
      'ol — только для меню, ul — только для таблиц и карточек.',
      'ol — когда порядок важен, ul — когда порядок не имеет значения.',
      'ul — для заголовков, ol — для цитат и источников.'
    ],
    correctAnswer: 2,
    explanation:
      'ol используют для последовательности действий, ul — для перечня без порядка. Меню, таблицы и заголовки не определяют выбор списка.'
  },
  {
    question: 'Для чего используется <dl>?',
    options: [
      'Для обычных списков, где порядок элементов не важен.',
      'Для заголовков, чтобы задать иерархию разделов.',
      'Для коротких цитат внутри абзаца без источника.',
      'Для пар «термин — определение» с использованием dt и dd.'
    ],
    correctAnswer: 3,
    explanation:
      'dl предназначен для терминов и их определений. Для обычных списков нужны ul/ol, а цитаты оформляют blockquote или q.'
  },
  {
    question: 'Как корректно оформить большую цитату с источником?',
    options: [
      'Использовать <q> для цитаты и <strong> для подписи автора.',
      'Использовать <blockquote> для цитаты и <cite> для источника.',
      'Использовать <p> для цитаты и <em> для фамилии автора.',
      'Использовать <div> для цитаты и <span> для указания источника.'
    ],
    correctAnswer: 1,
    explanation:
      'blockquote обозначает цитату как отдельный блок, а cite — источник. q подходит для коротких цитат внутри фразы, а div/span не задают смысл.'
  },
  {
    question: 'Как оформить короткую цитату внутри предложения?',
    options: [
      'Использовать <blockquote>, даже если цитата занимает одну строку.',
      'Использовать <em> и добавить кавычки вручную для выразительности.',
      'Использовать <q> для короткой цитаты внутри предложения.',
      'Использовать <span>, потому что это универсальный тег для фраз.'
    ],
    correctAnswer: 2,
    explanation:
      'q предназначен для коротких цитат внутри текста. blockquote выделяет отдельный блок, а em и span не сообщают смысл цитирования.'
  },
  {
    question: 'Какой тег использовать для фрагмента кода внутри текста?',
    options: [
      'Использовать <pre> для любого кода, даже если он короткий.',
      'Использовать <code> для небольшого фрагмента кода прямо в тексте.',
      'Использовать <kbd> для кода, как для команд пользователя.',
      'Использовать <samp> чтобы обозначить комментарий автора.'
    ],
    correctAnswer: 1,
    explanation:
      'code подходит для inline-фрагментов в тексте. pre нужен для блоков с сохранением форматирования, а kbd и samp имеют другие роли.'
  },
  {
    question: 'Когда нужен <pre>?',
    options: [
      'Когда нужно сохранить пробелы и переносы строк в блоке кода.',
      'Когда нужно выделить одно слово жирным внутри текста.',
      'Когда нужно показать ввод с клавиатуры для пользователя.',
      'Когда нужно указать дату публикации новости на странице.'
    ],
    correctAnswer: 0,
    explanation:
      'pre сохраняет форматирование и переносы строк, что важно для блоков кода. Он не используется для выделения текста, ввода или дат.'
  },
  {
    question: 'Какой тег подходит для ввода с клавиатуры?',
    options: [
      'Для вывода программы после выполнения команды или скрипта.',
      'Для любого технического текста, чтобы он выглядел моноширинным.',
      'Для отображения ввода с клавиатуры: кнопок и сочетаний.',
      'Для блока кода с сохранением форматирования и переносов строк.'
    ],
    correctAnswer: 2,
    explanation:
      'kbd обозначает клавиши и сочетания ввода, это видно пользователю. samp — вывод программы, code — код, pre — форматированный блок.'
  },
  {
    question: 'Какой тег подходит для вывода программы?',
    options: [
      'Для обозначения вывода программы или результата команды.',
      'Для обозначения клавиш, которые нажимает пользователь.',
      'Для выделения важного слова, чтобы подчеркнуть смысл.',
      'Для короткого цитирования внутри текста без источника.'
    ],
    correctAnswer: 0,
    explanation:
      'samp используется для вывода программы. kbd — ввод, em — смысловой акцент, q — цитата, поэтому эти варианты неверны.'
  },
  {
    question: 'Зачем использовать <time datetime="...">?',
    options: [
      'Чтобы визуально выделить дату без дополнительных тегов и CSS.',
      'Чтобы заменить заголовок и использовать дату как основной блок.',
      'Чтобы хранить случайные метки времени для дизайна.',
      'Чтобы дату читали люди и программы, указывая атрибут datetime.'
    ],
    correctAnswer: 3,
    explanation:
      'time с datetime делает дату машинно читаемой и сохраняет текст для человека. Это не способ декора и не замена заголовков.'
  },
  {
    question: 'Как правильно размечать сокращение?',
    options: [
      'Использовать <strong>, чтобы визуально показать важность сокращения.',
      'Использовать <em>, чтобы курсивом выделить сокращение в тексте.',
      'Использовать <abbr> с title, чтобы показать расшифровку сокращения.',
      'Использовать <span> без атрибутов, потому что он универсален.'
    ],
    correctAnswer: 2,
    explanation:
      'abbr с title раскрывает значение сокращения и помогает читателям. strong/em меняют акцент, а span не несет семантики.'
  },
  {
    question: 'Для чего используют <sub> и <sup>?',
    options: [
      'Для заголовков и подзаголовков, чтобы построить иерархию.',
      'Для нижних и верхних индексов в формулах вроде H2O и m².',
      'Для цитат и указания автора в конце абзаца.',
      'Для маркировки пунктов списка и нумерации.'
    ],
    correctAnswer: 1,
    explanation:
      'sub и sup нужны для индексов и степеней. Они не используются для заголовков, цитат или списков.'
  },
  {
    question: 'Почему текст лучше размещать в <p>, а не в <div>?',
    options: [
      'div нельзя использовать в body, поэтому p — единственный вариант.',
      'p автоматически добавляет метаданные и улучшает индексацию страницы.',
      'div делает текст доступным только для скринридеров и ассистентов.',
      'p задаёт смысл абзаца, div — нейтральный контейнер без семантики.'
    ],
    correctAnswer: 3,
    explanation:
      'p сообщает, что перед нами абзац, и задает смысл. div — универсальная обертка и не заменяет семантический тег.'
  },
  {
    question: 'Когда уместно использовать <div> или <span>?',
    options: [
      'Когда нужно оформить цитату и указать источник автора.',
      'Когда нет подходящего семантического тега и нужен контейнер.',
      'Когда требуется отметить дату публикации и её формат.',
      'Когда нужно создать новый абзац или заголовок текста.'
    ],
    correctAnswer: 1,
    explanation:
      'div и span используют как нейтральные контейнеры, если нет подходящего семантического тега. Цитаты, даты и заголовки имеют свои теги.'
  },
  {
    question: 'Где можно использовать <footer>?',
    options: [
      'Только внизу страницы, внутри статьи он обычно не нужен.',
      'Для любого нижнего блока, даже если это реклама или меню.',
      'В конце страницы или внутри статьи, как завершение блока.',
      'Только для контактов, другие сведения туда помещать не принято.'
    ],
    correctAnswer: 2,
    explanation:
      'footer завершает как страницу, так и отдельный раздел, например статью. Он не обязан содержать только контакты и не является просто «низом».'
  },
  {
    question: 'Почему нельзя использовать списки только ради отступов?',
    options: [
      'Списки ломают доступность и делают текст невидимым для поиска.',
      'Списки выражают перечень, а отступы лучше делать стилями.',
      'Списки запрещены в HTML5, если нет нумерации.',
      'Списки автоматически ухудшают производительность страницы и рендер.'
    ],
    correctAnswer: 1,
    explanation:
      'Списки передают смысл перечня, а не отступы. Для внешнего вида используйте CSS, иначе структура текста будет неверной.'
  }
];

async function updateHtmlTextSemanticsTest() {
  try {
    console.log(`🚀 Обновление вопросов для теста "${TEST_TITLE}"...\n`);

    let test = await prisma.test.findFirst({
      where: { title: TEST_TITLE }
    });

    if (!test) {
      test = await prisma.test.create({
        data: {
          title: TEST_TITLE,
          description: TEST_DESCRIPTION,
          difficulty: TEST_DIFFICULTY,
          tags: TEST_TAGS
        }
      });
      console.log(`✅ Тест создан: ${test.title}`);
    } else {
      await prisma.test.update({
        where: { id: test.id },
        data: {
          description: TEST_DESCRIPTION,
          difficulty: TEST_DIFFICULTY,
          tags: TEST_TAGS
        }
      });
      console.log(`✅ Тест обновлён: ${test.title}`);
    }

    const category = await prisma.category.findUnique({
      where: { slug: CATEGORY_SLUG }
    });

    if (category) {
      await prisma.categoryTest.upsert({
        where: {
          categoryId_testId: {
            categoryId: category.id,
            testId: test.id
          }
        },
        update: { order: CATEGORY_ORDER },
        create: {
          categoryId: category.id,
          testId: test.id,
          order: CATEGORY_ORDER
        }
      });
    }

    const lecture = await prisma.lecture.findFirst({
      where: { title: TEST_TITLE },
      orderBy: { createdAt: 'desc' }
    });

    if (!lecture) {
      throw new Error('Лекция не найдена. Сначала создайте лекцию.');
    }

    const existingLinks = await prisma.testQuestion.findMany({
      where: { testId: test.id }
    });

    const oldQuestionIds = existingLinks.map((link) => link.questionId);

    await prisma.testQuestion.deleteMany({
      where: { testId: test.id }
    });

    for (const questionId of oldQuestionIds) {
      const usageCount = await prisma.testQuestion.count({
        where: { questionId }
      });
      if (usageCount === 0) {
        await prisma.question.delete({ where: { id: questionId } });
      }
    }

    let createdCount = 0;

    for (let i = 0; i < questions.length; i++) {
      const q = questions[i];

      const newQuestion = await prisma.question.create({
        data: {
          question: q.question,
          options: q.options,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation,
          lectureId: lecture.id
        }
      });

      await prisma.testQuestion.create({
        data: {
          testId: test.id,
          questionId: newQuestion.id,
          order: i + 1
        }
      });

      createdCount++;
    }

    console.log(`✅ Вопросов создано: ${createdCount}`);
    console.log(`📌 Тест: ${test.title}`);
    console.log(`📚 Лекция: ${lecture.id}`);
  } catch (error) {
    console.error('❌ Ошибка:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
    await pool.end();
  }
}

updateHtmlTextSemanticsTest();
